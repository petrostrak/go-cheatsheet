package main

import "fmt"

func main() {
	stringStream := make(chan string)

	go func() {
		// Here we pass a string literal onto the channel stringStream
		stringStream <- "Hello channels!"
	}()

	// Here we read the string literal off of the channel and print it out to stdout
	// fmt.Println(<-stringStream)

	// The receiving form of <- operator can also optionally return two values
	// The boolean return value is a way for a read operatoon to indicate whether
	// the read off the channel was a value generated by a write elsewhere in the
	// process, or a default value generated from a closed channel.
	salutation, ok := <-stringStream
	fmt.Printf("(%v): %v\n", ok, salutation)
}

// Why the anonymous goroutine completes before the main goroutine?
//
// This example works because channels in Go are said to be blocking. This means that
// any goroutine that attempts to write to a channel that is full, will wait until the
// channel has been emptied, and any goroutine that attempts to read from a channel that
// is empty, will wait until at least one item is placed on it.
// Thus, the main goroutine and the anonymous goroutine block deterministically.
